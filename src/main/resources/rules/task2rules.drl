//created on: 2017.03.29.
package onlab.event

global onlab.utility.ProfitableAreaToplistSet mostProfitableAreas
//list any import classes here.

import onlab.positioning.*
import org.kie.api.runtime.rule.QueryResults
import accumulate onlab.utility.MedianAccumulateFunction median

//declare any global variables here
declare TaxiLog
@role(event)
@timestamp(dropoff_datetime)
//@expires( 32m )
end

declare Tick
@role(event)
@timestamp(currentTime)
@expires( 1s )
end

declare RefreshArea
@role(event)
@timestamp(currentTime)
end



rule "new_TaxiLog_rule"

    when
      $tlog: TaxiLog(!processed, $pickupCell: pickup_cell , $dropoffCell: dropoff_cell , $currentTime: dropoff_datetime )
      
    then
      $tlog.setProcessed(true);
      update($tlog);
      insertLogical(new RefreshArea($pickupCell, $currentTime));
      insertLogical(new RefreshArea($dropoffCell, $currentTime));
             

end




rule "refreshArea"

	when
		RefreshArea($cell:cell , $ctime: currentTime )
		$medianProfit : java.lang.Number(doubleValue > 0) from accumulate 
        			( TaxiLog($fare: fare_amount , $tip:tip_amount , pickup_cell == $cell) over window:time(15m);
        			median($fare.add($tip))
        			)
        $taxiListOfArea: java.util.ArrayList() from collect (TaxiLog(dropoff_cell == $cell) over window:time(30m))
	then	
	
		int $counter = 0;
		for(Object $o : $taxiListOfArea){
			TaxiLog $tlog = (TaxiLog)$o;
			QueryResults results =
    		kcontext.getKnowledgeRuntime().getQueryResults( "newerRidesOfDriver", new Object[]{$tlog.getHack_license(), $tlog.getDropoff_datetime()} );
    		if(results.size() == 0){
    			$counter++;
    		}
		}
		
		mostProfitableAreas.add(new AreaWithProfit($cell, $medianProfit.doubleValue() / $counter , $ctime));
end

query "newerRidesOfDriver"  (String $license, java.util.Date $threshold)

      $tlog: TaxiLog(hack_license.equals($license) , $threshold.before(dropoff_datetime) )
end
/*
rule "TaxiLog_decrease2"

    when
        $tick:Tick($currentTime : currentTime )
    then
    	mostProfitableAreas.refresh($currentTime); 
       
        

end
*/

