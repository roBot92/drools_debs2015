package onlab.event




//list any import classes here.
//import accumulate MedianAccumulateFunction medianf
import onlab.positioning.*
import org.kie.api.runtime.rule.QueryResults
import java.math.BigDecimal
import java.util.ArrayList
import java.util.Date
import accumulate onlab.utility.MedianAccumulateFunction median


//declare any global variables here
global onlab.utility.ProfitableAreaToplistSet mostProfitableAreas
 


declare TaxiLog 
@role(event)
@timestamp(dropoff_datetime)
@expires( 30m 1s)
end

declare Tick
@role(event)
@timestamp(currentTime)
@expires( 1s )
end



declare RefreshAreaMedian
cell : Cell
insertTime : long
end

declare RefreshAreaCount
cell : Cell
license : String
insertTime : long
end

declare ActivateArea
@role(fact)
end

declare TaxiLocation
@role(event)
cell:Cell
license:String
currentTime:Date @timestamp
end


declare AreaWithProfit
@role(event)
@timestamp(lastInserted)
end

//Kidobjuk az érvénytelen TaxiLog-okat: hiányzik valamelyik cella, vagy viteldíj <=0 USD.
rule task2_removeInvalidTaxiLog
salience 1
	when
		$tlog: TaxiLog(pickup_cell == null || dropoff_cell == null || fare_amount.compareTo(BigDecimal.ZERO) < 1)
	then
		
		retract($tlog);
end


//A még fel nem dolgozott TaxiLog-okra aktiválódik. Aktiválja a két AreaWithProfit-ot a WM-ben a két cellának megfelelõen, illetve 
//meghívja rájuk a kezdõ cellára a medián frissítést, és a befejezõre a szám frissítést.
rule "task2_new_TaxiLog_rule" 
salience 0
    when
      $tlog: TaxiLog(!processed, $pickupCell: pickup_cell , $dropoffCell: dropoff_cell , $currentTime: dropoff_datetime , $inserted: inserted, $hack_license: hack_license )
      
    then
    
      insertLogical(new ActivateArea($pickupCell, $currentTime));
      insertLogical(new ActivateArea($dropoffCell, $currentTime));
      insert(new RefreshAreaMedian($pickupCell, $currentTime.getTime()));
      insert(new RefreshAreaCount($dropoffCell, $hack_license, $currentTime.getTime()));
      $tlog.setProcessed(true); 
      update($tlog);

end


//Létrehozza az új AreaWithProfit-ot a WM-ben, ha még nem létezik.
rule "task2_activateArea_rule"
salience 1
	when 
		$activateArea:ActivateArea($pickupCell: cell, $currentTime : currentTime)
		not AreaWithProfit(cell == $pickupCell)
	then
		
		insert(new AreaWithProfit($pickupCell, $currentTime));
end

//Kiszámolja a mediánt az adott AreaWithProfit-ra.
rule "task2_refreshAreaMedian_rule"
salience -1
	when
		$tick:Tick(  )
		RefreshAreaMedian($cell:cell)
		$area:AreaWithProfit(cell == $cell)
		//Legyûjtjük az összes RefreshAreaMedian objektumot, hogy csak egyszer fusson.
		$refList: ArrayList() from collect (RefreshAreaMedian($cell == cell))
		//Használjuk a létrehozott medián akkumuláló függvényt az összes, elmúlt negyed órában befejezett TaxiLog-ra a területen.
		$medianOfCell: BigDecimal() from accumulate 
				(TaxiLog(pickup_cell == $cell, $fare:fare_amount, $tip:tip_amount,this before[0m,15m] $tick), 
					median($fare.add($tip)))					
	then
		
		//Elõször kitöröljük a toplistából, hogy a rendezés koherens maradjon.
		mostProfitableAreas.remove($area);
		long $ctime = -1;
		//Kitöröljük a legyûjtött egyforma RefreshAreaMedian eseményeket. Ha találunk olyat, ahol van insertTime (tehát új TaxiLog aktiválta)
		//ott elmentjük az insertTime-ot. Helyes mûködés esetén ebbõl egyféle lehet, a jelenlegi idõ.
		for(Object $o : $refList){
			RefreshAreaMedian $ram = (RefreshAreaMedian) $o;
			if($ram.getInsertTime() > -1){
				$ctime = $ram.getInsertTime();
			}
			retract($o);
		}
		//Ha találtunk currentTime-ot, beállítjuk.
		if($ctime != -1){
			$area.setLastInserted(new Date($ctime));
		}
		//Beállítjuk az új mediánt.
		$area.setMedianProfit($medianOfCell);
		update($area);
		mostProfitableAreas.add($area);
			
end

/*
rule "task2_RefreshAreaMedianToNull"
salience -2
	when
		Tick()
		RefreshAreaMedian($cell:cell)
		$area:AreaWithProfit(cell == $cell)
		$refList: ArrayList() from collect (RefreshAreaMedian($cell == cell))
	then
		System.out.println("task2_RefreshAreaMedianToNull");
		mostProfitableAreas.remove($area);
		$area.setMedianProfit(BigDecimal.ZERO);
		for(Object $o : $refList){
			retract($o);
		}
end*/

//Megnöveli az adott AreaWithProfit-nak a count-ját, vagyis a rajta potenciálisan tartózkodó taxik számát.
rule "task2_increaseAreaCount_rule"
salience -1
	when
		$ref:RefreshAreaCount($cell:cell, $time:insertTime, $license:license)
		$area:AreaWithProfit( $cell==cell )
	then 
		//Elõször kitörli az area-t a toplistából, hogy a rendezés konzisztens maradjon.
		mostProfitableAreas.remove($area);
		//Megnöveli a count-o, és beállítja az insertTime-ot (a jelenlegi idõt)
		$area.increaseCountOfTaxes();
		$area.setLastInserted(new Date($time));		
		update($area);
		mostProfitableAreas.add($area);
		
		//Végül beilleszt egy TaxiLocation fact-ot, majd kitörli a RefreshAreaCount-ot.
		insert(new TaxiLocation($cell, $license, new Date($time)));    	 
		retract($ref);
end

//Akkor aktiválódik, ha két TaxiLocation-t talál ugyanarra a sofõrre, illetve a régebbi lokációhoz talál AreaWithProfit-ot is.
rule "task2_decreaseTaxiCountOnDriversPreviousCell"
salience -2
	when
		$newTlocation: TaxiLocation($license:license)
		$oldTlocation: TaxiLocation(license.equals($license), $cell:cell, this before $newTlocation)
		$area:AreaWithProfit( cell == $cell )
	then
		//A régebbi TaxiLocation-höz tartozó AreaWithProfit-ot kitörli a toplistából, lecsökkenti a rajta tartózkodó potenciális
		//taxik számát (count), majd visszateszi a toplistába, végül kitörli a régebbit.
		mostProfitableAreas.remove($area);
		$area.decreaseCountOfTaxes();
		$area.setLastInserted($newTlocation.getCurrentTime());
		update($area);
		mostProfitableAreas.add($area);
		retract($oldTlocation);
end

//A 30 percnél régebbi TaxiLocation-ökre aktiválódik.
rule "task2_expiringTaxiLocationRule"
salience 1
	when
		$tick:Tick()
		$tlocation:TaxiLocation($cell:cell, this before[30m1s,*] $tick)
		$area:AreaWithProfit( cell == $cell )
	then
	//Lecsökkenti TaxiLocation-höz tartozó AreaWithProfit-on potenciálisan tartózkodó taxik számát, majd kitörli a lokációt.
		mostProfitableAreas.remove($area);
		$area.decreaseCountOfTaxes();
		update($area);
		mostProfitableAreas.add($area);
		
		retract($tlocation);
end

//Minden TaxiLog-ra aktiválódik egyszer, ami már 15 percnél régebbi.	
rule "task2_refreshMedianAfter15Min"
salience 1
	when
		$tick:Tick()
		$tlog:TaxiLog(!olderThanAQuarter, this before[15m1s,*] $tick)	
	then
		//Beilleszt egy új RefreshAreaMedian tényt a WM-be, hogy frissüljön a pickupCell-hez tartozó medián.
		$tlog.setOlderThanAQuarter(true);
		update($tlog);	
		insert(new RefreshAreaMedian($tlog.getPickup_cell(), -1));
end

//Kitörli azokat az AreaWithProfit-okat, amiknek már mindene 0, és régebbiek, mint fél óra. 
rule "task2_deactivateArea"
salience -5
	when
		$tick:Tick(  )
		$area: AreaWithProfit(countOfTaxes == 0, medianProfit.compareTo(BigDecimal.ZERO)<1, this before[30m1s,*] $tick )
	then
		mostProfitableAreas.remove($area);
		retract($area);
end
		





query "task2_ridesOfDriver"  (String $license, java.util.Date $threshold)

      tlog:TaxiLog(hack_license.equals($license) , $threshold.before(dropoff_datetime) )
end

//For debug
query "areas"  ()

      areas:AreaWithProfit()
end

query "taxis"()
	taxis: TaxiLog()
end