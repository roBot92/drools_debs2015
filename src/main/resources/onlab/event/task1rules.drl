
//created on: 2017.03.29.
package onlab.event




//list any import classes here.
import onlab.positioning.*
import org.kie.api.runtime.rule.QueryResults
import java.math.BigDecimal
import java.util.ArrayList
//import onlab.utility.CustomTreeMultiset



//declare any global variables here
global onlab.utility.ProfitableAreaToplistSet mostProfitableAreas
global onlab.utility.FrequentRoutesToplistSet mostFrequentRoutes



declare TaxiLog
@role(event)
@timestamp(dropoff_datetime)
end

declare Tick
@role(event)
@timestamp(currentTime)
@expires( 999ms )
end


declare ActivateRoute
@role(fact)
end

declare RefreshRoute
@role(fact)
end

declare Route
@role(event)
@timestamp(lastDropoffTime)
end



//Kitörli azokat a TaxiLog rekordokat, amikben nincs meg valamelyik cella, vagyis érvénytelenek. Priroritása miatt elõbb aktiválódik, mint a task1_newTaxiLog szabály
rule task1_removeInvalidTaxiLog
salience 1
	when
		$tlog: TaxiLog(pickup_cell == null || dropoff_cell == null)
	then
		retract($tlog);
end

//Az új TaxiLogokat feldolgozó szabály. Aktiválja az utat, (az aktiváló szabály akkor fut le, ha még nincs ilyen Route a WM-ban), illetve
//beilleszt egy RefreshRoute eseményt, majd a processed flag-et beállítja, hogy többet ne fusson már a szabály az adott TaxiLog-ra.
rule task1_newTaxiLog
salience 0
	when
			$tlog:TaxiLog( !processed, $pickupCell: pickup_cell, $dropoffCell: dropoff_cell, $dropoffDate: dropoff_datetime, $inserted : inserted)
	then
			
			insertLogical(new ActivateRoute($pickupCell, $dropoffCell,$dropoffDate));
			insert(new RefreshRoute($pickupCell, $dropoffCell, $dropoffDate.getTime(), $inserted));
			$tlog.setProcessed(true);
			update($tlog);
end

//Létrehoz egy új Route objektumot, ha talál ActivateRoute tényt, és nem talál Route megfelelõt
rule task1_activateRoute
salience 10
	when
		ActivateRoute($pickupCell : pickup_cell, $dropoffCell: dropoff_cell, $ctime : lastInserted)
		not Route($pickupCell == pickup_cell, $dropoffCell == dropoff_cell)
	then
		insert(new Route($pickupCell, $dropoffCell, $ctime , 1));
end


rule task1_refreshRoute
salience -1
	when
		 $ref:RefreshRoute($pickupCell : pickup_cell, $dropoffCell : dropoff_cell )
		 $route: Route($pickupCell == pickup_cell, $dropoffCell == dropoff_cell)
		 //A RefreshRoute eseményeket azért gyûjtjük egybe, hogy a szabály ne fusson le egy frissítésnél többször ugyanarra az útvonalra
		 $refList: ArrayList() from collect( RefreshRoute(pickup_cell == $pickupCell, dropoff_cell == $dropoffCell) )
		 $countOfRoutes : java.lang.Number() from accumulate (
			TaxiLog($pickupCell == pickup_cell, $dropoffCell == dropoff_cell ),//ez nem kell, mivel elõbb kitöröljük a TaxiLog-ot over window:time(30m1s),
			count()
		 )
		 
		 $avgOfInsertedTime: java.lang.Double() from accumulate (
			RefreshRoute($pickupCell == pickup_cell, $dropoffCell == dropoff_cell, insertedForDelay  > -1, $insertedForDelay:insertedForDelay ),
			average($insertedForDelay)
		 )
		
	then
		//Elõször kitöröljük a toplistából, mivel ha enélkül változtatunk benne értéket, késõbb nem találja meg a TreeSet
		mostFrequentRoutes.remove($route);
		//Ha 0 a szám, akkor kitöröljük az utat és a refresh eseményeket.
		if($countOfRoutes.intValue() == 0){
			
			retract($route);
			for(Object $o : $refList){
				retract($o);
			}
		}//Végigmegyünk a legyûjtött RefreshRoute listán, ha találtunk új currentTime-ot (ami azt jelenti, hogy új TaxiLog jött, és nem egy régi TaxiLog okozza a frissítést
		//akkor azt elmentjük, mert az lesz beállítva a Route új frissítési idejének.
		//Végül mindegyik RefreshRoute elemet kitöröljük a WM-bõl.
		else{
			long $ctime = -1;
			for(Object $o : $refList){
				RefreshRoute $rr = (RefreshRoute) $o;
				if($rr.getCurrentTime() > -1){
					$ctime = $rr.getCurrentTime();
				}
				retract($o);
			}
			//Ha volt új currentTime, azt beállítjuk a Route lastDropoffTime-jának, illetve a Delay-t -1-re állítjuk, ezzel jelezve a Toplistnek, hogy újra kell számolni.
			if($ctime != -1){
			$route.setLastDropoffTime(new java.util.Date($ctime));
			$route.setDelay(-1);
			$route.setInsertedForDelay($avgOfInsertedTime.longValue());
		 	}
		 //Beállítjuk az új frequency-t is, jelezzük a módosítást a WM-nek, majd visszatesszük a listába.
		 $route.setFrequency($countOfRoutes.longValue());
		 update($route);
		 mostFrequentRoutes.add($route);
		}
		
end


//A szabály legyûjti azokat a TaxiLog-okat, amik 30 percnél régebbiek, létrehoz egy RefreshRoute eseményt rájuk, majd kitörli õket.
rule task1_removeTaxiLogsFromRoute 
salience 4
	when
		$tick: Tick($ctime : currentTime)
		$tlogs: ArrayList() from collect( TaxiLog( this before[30m1s, *] $tick) )
	then
		
		for(Object $o : $tlogs){
			TaxiLog $tlog = (TaxiLog)$o;
			insert(new RefreshRoute($tlog.getPickup_cell(), $tlog.getDropoff_cell(), -1, -1));		
			retract($tlog);
		}
		
end



//For debug
query "routes"  ()

      routes: Route()
end

query "taxis"()
	taxis: TaxiLog()
end

query "refresh"
	refresh: RefreshRoute()
end